
# miniJava-Compiler
This repository is a compiler written in Java that translates miniJava to assembly language for the miniJava Abstract Machine (mJAM).

miniJava is a small subset of java that supports Primitive Types (Integer, Boolean), Strings, Arrays, Classes, Encapsulation, Methods, Conditionals.

The grammar for miniJava is specified below. A miniJava program is a file (with extension .java or .mJava) that contains a series of class declarations. A valid miniJava program must contain exactly 1 entry method with the signature `public static void main(String[] args)`. Source programs may refer to the prefined methods `System.out.println()` and `System.out.printStr()` which can be used to print integers and strings respectively.

The compiler expects exactly one arguement which is the path to a miniJava file. If the file has any syntactic or contextual errors a message will be outputted to the console and execution will stop. If the file is a valid miniJava program, then an `.asm` file with the same name will be outputted (there will also be a `.mJAM` file with the binary equivalent).

The source folder contains a mJAM package and the Interpreter can be used to interpret valid files outputted by the compiler.

## Compilation Process
The compiler can be broken down into 4 main phases.
1. Tokenization
	* The source program is translated into a stream of Tokens
	* Tokens represent the smallest building blocks of miniJava programs
	* For example, the string `public int x = 5;` would get translated into the tokens `['public, 'int', 'x', '=', '5', ';']`
	* This phase of compilation will catch certain syntactic errors such as using invalid characters, unterminated comments, unsupported operators, etc.
	* Once the source program has generated a series of tokens, the tokens are parsed to the parser (well not quite but it's easier explained like this)
2. Parsing
	* The parser will take the stream of Tokens and generate an Abstract Syntax Tree (AST) that represents the source of the program
	* All remaining syntax errors are caught in this phase
	* The root of the tree is a `Package` instance
	* `src/miniJava/AbstractSyntaxTrees` contains all of the other node types in the trees
	* A hierarchy of all the AST Classes is provided below
3. Contextual Analysis
	* Contextual Analysis takes the AST generated by the parser and performs two verifications: Identification and Type Checking
	* In identification, applied uses of variables are linked to their declarations
	* In identification, we catch errors such as referencing an undefined variable
	* Identification must also account for scoping levels since you can have multiple variables with the same name
	* Type Checking ensures that the types of all variables are consistent with expected types. This phase will catch issues such as attempting to assign a boolean to a variable of type integer or perhaps calling a method with an incorrect number/type of arguements
	* Once Contextual Analysis is complete, a decorated AST is given to the code generator
4. Code Generation
	* The code generator will traverse the AST, generating code for the target machine
	* The entry point for the machine will be the main method as described above
	* The final output will be written to the corresponding .asm and .mJAM files

## Example Program
The test directory contains a series of both valid and invalid miniJava files that were used to test the compiler as I developed it.

One program, for example, prints factorials of various numbers.

Source:
```
class Runner {
	public static void main(String[] args) {
		int i = 0;
		while (i < 5) {
			i = i +1;
			System.out.println(factorial(i));
		}
	}
	
	public static int factorial(int n) {
		if (n <= 1) {
			return 1;
		}
		return n * factorial(n-1);
	}
}
```

Compiler Output:
```
  0         PUSH         1
  1         LOADL        0
  2         CALL         newarr  
  3         CALL         L13
  4         POP          1
  5         HALT   (0)   
  6  L10:   LOAD         -1[LB]
  7         CALL         putintnl
  8         RETURN (0)   1
  9         LOADL        1
 10         LOAD         -1[LB]
 11         LOADL        0
 12         CALL         fieldref
 13  L11:   LOAD         3[LB]
 14         LOAD         4[LB]
 15         CALL         le      
 16         JUMPIF (1)   L12
 17         CALL         puteol  
 18         RETURN (0)   1
 19  L12:   LOAD         -1[LB]
 20         LOAD         3[LB]
 21         CALL         fieldref
 22         CALL         put     
 23         LOAD         3[LB]
 24         LOADL        1
 25         CALL         add     
 26         STORE        3[LB]
 27         JUMP         ***
 28  L13:   PUSH         1
 29         LOADL        0
 30         STORE        3[LB]
 31         JUMP         L15
 32  L14:   LOAD         3[LB]
 33         LOADL        1
 34         CALL         add     
 35         STORE        3[LB]
 36         LOAD         3[LB]
 37         CALL         L16
 38         LOAD         0[SB]
 39         CALLI        L10
 40  L15:   LOAD         3[LB]
 41         LOADL        5
 42         CALL         lt      
 43         JUMPIF (1)   L14
 44         RETURN (0)   1
 45  L16:   LOAD         -1[LB]
 46         LOADL        1
 47         CALL         le      
 48         JUMPIF (0)   L17
 49         LOADL        1
 50         RETURN (1)   1
 51  L17:   LOAD         -1[LB]
 52         LOAD         -1[LB]
 53         LOADL        1
 54         CALL         sub     
 55         CALL         L16
 56         CALL         mult    
 57         RETURN (1)   1
```

Output when interpreted
```
>>> 1
>>> 2
>>> 6
>>> 24
>>> 120
```

## Grammar

The original miniJava grammar fails to account for operator precedence. The grammar (particularly for the expression rule) had to be stratified to implicitly include operator precedence in the parse structure. The final grammar for the Expression rule is given below.

Although not included in the grammar, miniJava supports line comments (`//`) and block comments (`/* */`).
```
Expression 		-> Precedence0
Precedence0		-> Precedence1 ('||' Precedence1)*
Precedence1		-> Precedence2 ('&&' Precedence2)*
Precedence2		-> Precedence3 (('==' || '!=') Precedence3)*
Precedence3		-> Precedence4 (('<=' || '<' || '>' || '>=')) Precedence4)*
Precedence4		-> Precedence5 (('+' || '-') Precedence5)*
Precedence5		-> Precedence6 (('*' || '/') Precedence6)*
Precedence6		-> (('-' || '!') Precedence6) | Final
Final			-> num | 
			'(' Expression ')' | 
			Reference | 
			Reference[Expression] | 
			Reference(ArguementList?) |
			true | 
			false | 
			null |
			'"' StringLiteral '"' | 
			new (id() | int[Expression] | id[Expression])
```

The operator precedence is as given (from lowest to highest)
| Class      | Operator |
| ----------- | ----------- |
| Disjunction      | &#124;&#124;       |
| Conjunction   | &&        |
| Equality   | ==,!=        |
| Relational   | <=,<,>,>=  |
| Additive   | +,-        |
| Multiplicative   | \*,/        |
| Unary   | -,!        |


## AST Class Explanations
```
AST
    Terminal
		BooleanLiteral
		IntLiteral
		Identifier
		Operator
	Expression
		Binary Expression
		CallExpr (Effectively same as CallStmt)
		IxExpr
		LiteralExpr
		UnaryExpr
		RefExpr
		NewExpr
			NewArrayExpr
			NewObjectExpr
	TypeDenoter
		ArrayType
		BaseType
		ClassType
	Declaration
		ClassDecl, ClassDeclList
		MemberDecl todo
			FieldDecl, FieldDeclList
			MethodDecl, MethodDeclList
		LocalDecl
			ParameterDecl, ParameterDeclList
			VarDecl
	Statement, StatementList
		BlockStmt
		IfStmt
		WhileStmt
		ReturnStmt
		AssignStmt
		IxAssignStmt (Indexed AssignStmt)
		CallStmt
		VarDeclStmt
	Reference
		BaseRef
			IdRef
			ThisRef
		QualRef	
.
├── AST (Abstract Class)
|		Top Level Abstract Class
├── ASTDisplay
|		Visitor class for display AST Textual Representation
├── ArrayType extends TypeDenoter (Concrete Class)
|		Maintains a TypeDenoter that represents the type of the Element.
|		Calls the TypeDenoter constructor with the Array TypeKind
├── AssignStmt extends Statement (Concrete Class)
|		Maintains a Reference, Expressino (Reference = Expression)
├── BaseRef extends Reference (Abstract Class)
|		Holds Nothing
├── BaseType extends TypeDenoter (Concrete Class)
|		Concrete wrapper class that just maintains a TypeKind
├── BinaryExpr extends Expression (Concrete Class)
|		Holds an Operator, and Two Expressions (left and right)
├── BlockStmt extends Statement (Concrete Class)
|		Maintains a StatementList
├── BooleanLiteral extends Terminal (Concrete Class)
|		Concrete class that holds no new information, just signifies that this terminal is a boolean literal
├── CallExpr extends Expression (Concrete Class)
|		Maintains a Reference and ExprList (Reference(ArguementList?);)
├── CallStmt extends Statement
|		Maintains a Reference and ExprList (Reference(ArguementList?);)
├── ClassDecl extends Declaration (Concrete Class)
|		Maintains class name (String), FieldDeclList, and MethodDeclList
├── ClassDeclList implements Iterable<ClassDecl> (Concrete Class)
|		Just maintains a list of ClassDecl's
├── ClassType extends TypeDenoter (Concrete Class)
|		Maintains the class name as an Identifier Objec
|		Calls the TypeDenoter constructor with the Class TypeKind. Used in NewObjectExpr.
├── Declaration extends AST (Abstract Class)
|		Stores a declaration as a name (String) and type (TypeDenoter)
├── ExprList implements Iterable<Expression> (Concrete Class)
|		Maintains a list of expressions. Used in function calls.
├── Expression extends AST (Abstract Class)
|		Extends AST but adds nothing new and is still abstract
├── FieldDecl extends MemberDecl (Concrete Class)
|		Just a concrete class that has nothing new from MemberDecl, fields have no more information
├── FieldDeclList implements Iterable<FieldDecl> (Concrete Class)
|		Just a wrapper for having a list of FieldDecl's, used in ClassDecl
├── IdRef extends BaseRef (Concrete Class)
|		Maintains an Identifier
├── Identifier extends Terminal (Concrete Class)
|		Concrete class that holds no new information, just signifies that this terminal is an identifier
├── IfStmt extends Statement (Concrete Class)
|		Maintains an Expression for the condition, Statement for true case, Statement for else case
|		Has two constructors based on presence of else statement, if no else statement then null stored internally
├── IntLiteral extends Terminal (Concrete Class)
|		Concrete class that holds no new information, just signifies that this terminal is an integer literal
├── IxAssignStmt extends Statement (Concrete Class)
|		Maintains Reference, Expression for index, Expression for assign value (Reference[Expression]=Expression)
├── IxExpr extends Expression (Concrete Class)
|		Maintains Reference and Expression (Reference[Expression])
|		Question: Test Ref[Ref[Ref[Expr]]]
├── LiteralExpr extends Expression (Concrete Class)
|		Maintains a Terminal represent a literal
├── LocalDecl extends Declaration (Abstract Class)
|		Abstract filler class, holds no info
├── MemberDecl extends Declaration (Abstract Class)
|		boolean isPrivate, boolean isStatic, TypeDenoter, String name (these are common to both fields and methods)
├── MethodDecl extends MemberDecl
|		Takes in a MemberDecl (which has to be a FieldDecl since that is the only other concrete implementation
|		Also recieves a ParameterList and a StatementList
├── MethodDeclList implements Iterable<MethodDecl> (Concrete Class)
|		Just a wrapper for having a list of MethodDecl's, used in ClassDecl
├── NewArrayExpr extends NewExpr (Concrete Class)
|		Has a TypeDenoter for the element type, Expression for the size of the array
├── NewExpr extends Expression (Abstract Class)
|		Just a top level class for making a new array/object
├── NewObjectExpr extends NewExpr (Concrete Class)
|		Maintains ClassType	
├── Operator extends Terminal (Concrete Class)
|		Concrete class that holds no new information, just signifies that this terminal is an operator
├── Package extends AST (Concrete Class)
|		Top Level Node in AST, Just has a ClassDeclList
├── ParameterDecl extends LocalDecl (Concrete Class)
|		Holds no new info, calls parent constructor with String name and TypeDenoter
├── ParameterDeclList implements Iterable<ParameterDecl> (Concrete Class)
|		Just a wrapper for having a list of ParameterDecl's, used in MethohdDecl
├── QualRef extends Reference (Concrete Class)
|		Mantains a Reference an Identifier
|		A dot followed by a particular field 
|		Question: How to nest these?
├── RefExpr extends Expressin (Concrete Class)
|		Maintains just a Reference
├── Reference extends AST (Abstract Class)
|		Holds Nothing
├── ReturnStmt extends Statement (Concrete Class)
|		Maintains an expression for the return value
|		Question: do we just put null if there is no return value
├── Statement extends AST (Abstract Class)
|		Top Level Class for all the specific statement types, holds no info
├── StatementList implements Iterable<Statement> (Concrete Class)
|		Just a wrapper for having a list of Statements's, used in MethodDecl, BlockStmt
├── Terminal extends AST (Abstract Class)
|		Abstract class that just wraps a Token, stores the TokenType and it's spelling, discards the Token
├── ThisRef extends BaseRef (Concrete Class)
|		Holds nothing, Question: how/when does this get used in this.x.a...
├── TypeDenoter extends AST (Abstract Class)
|		Abstract wrapper class that contains a TypeKind
├── TypeKind (Enum)
|		Enumeration of the different variable types {void, int, booolean, class, array, unsupported, error}
|			Question: When to use unsupported or error? or even class since ClassDecl doesn't
├── UnaryExpr extends Expression (Concrete Class)
|		Mantains Operator and Expression
├── VarDecl extends LocalDecl (Concrete Class)
|		Maintains a TypeDenoter and String name. Used in VarDeclStmt.
├── VarDeclStmt extends Statement (Concrete Class)
|		Maintains a VarDecl, and Expression (VarDecl=Expression;)
├── Visitor
|		Defines the visitor interface for our traversals
└── WhileStmt extends Statement (Concrete Class)
|		Maintains an Expression for the conditioon, and a Statement for the body
```

## Logging